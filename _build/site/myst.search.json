{"version":"1","records":[{"hierarchy":{"lvl1":"Домашнее задание №2"},"type":"lvl1","url":"/2","position":0},{"hierarchy":{"lvl1":"Домашнее задание №2"},"content":"Это домашнее задание нацеленно не только на закрепление материала второй лекции, но и на закрепление ряда хороших python практик. Всего от вас требуется реализовать и протестировать 6 функций:\n\nфильтрация пропущенных значений;\n\nарифметическое среднее;\n\nгеометрическое среднее;\n\nгармоническое среднее;\n\nмедиана;\n\nрасстояние между объектами.\n\nПеред реализацией самих функций прочитайте дополнительный материал. При реализации функций старайтесь избегать плохих практик, упомянутых в дополнительном материале.","type":"content","url":"/2","position":1},{"hierarchy":{"lvl1":"Домашнее задание №2","lvl2":"Проверка типа объекта"},"type":"lvl2","url":"/2#id","position":2},{"hierarchy":{"lvl1":"Домашнее задание №2","lvl2":"Проверка типа объекта"},"content":"Иногда необходимо проверять тип объекта, например, для того чтобы в зависимости от типа совершить те или иные действия. В C/C++ для этого нередко применяют \n\nad hoc полиморфизм, т.е. пишут несколько реализаций одной и той же функции с разной сигнатурой, каждая из которых может по своему обрабатывать набор аргументов соответствующих типов.\n\nВ python достичь схожего эффекта просто так невозможно, т.к. а) тип параметров не указывается при объявлении функции, б) перегружать функции в python нельзя: повторное объявление функции с таким же именем затрет первичное объявление, даже если количество формальных параметров отлично. Хотя в python и принято писать такой код, который универсально обрабатывает объекты разных типов, иногда может возникнуть необходимость в модификации поведения функции в зависимости от типа аргумента. Особенно часто такое будет возникать на этапах освоения python, в период пока вы все ещё думаете в терминах C/C++.\n\nВ таких случая принято использовать функцию \n\nisinstance, которая первым аргументом принимает объект, вторым аргументом класс (он же тип), и возвращает True, если переданный объект является экземпляром указанного класса.isinstance(объект, класс)\n\nНапример, проверим, является ли объект \"Hello, world!\" целым числом или строкой?\n\nis_integer = isinstance(\"Hello, world!\", int)\nis_string = isinstance(\"Hello, world!\", str)\n\nprint(f'{is_integer=}, {is_string=}')\n\n\n\nНачинающие иногда используют вместо isinstance(объект, класс) конструкцию вида type(объект) == класс. Эти выражения во многих случаях эквиваленты, но считается хорошей практикой всегда прибегать к первому варианту. Разница между этими двумя выражениями наблюдается тогда, когда объект не является экземпляром непосредственно указанного класса, а является экземпляром производного класса.\n\nВ качестве примера рассмотрим абстрактный базовый класс \n\nNumber для всех чисел в python. Все встроенные числовые типы являются производными классами от класса Number, и функция isinstance всегда вернет корректное значение, а непосредственное сравнение на тип может обмануть.\n\nfrom numbers import Number\n\nx = 1\n\nprint(f\"{type(x) == Number = }\")\nprint(f\"{isinstance(x, Number) = }\")\n\n\n\nПример в ячейке выше демонстрирует, что если непосредственно сравнивать тип целого числа 1 с типом Number, то получается значение False. В подавляющем большинстве ситуация экземпляры производного класса должны обладать всеми необходимыми свойствами, чтобы квалифицироваться и в качестве экземпляров базового класса. Поэтому непосредственная проверка на тип считается плохой практикой, а хорошей практикой считается использование функции isinstance.\n\nНиже демонстрируется мощь такого подхода. Если сравнивать с Number, то ваш код автоматически будет работать со всеми встроенными числовыми типами, но его можно будет даже расширять и пользовательскими числовыми типами без модификации кодовой базы при корректном использовании принципов объектно-ориентированного программирования.\n\nfrom numbers import Number\n\n\ndef check_types(x):\n    t = type(x)\n    is_number = isinstance(x, Number)\n    is_float = isinstance(x, float)\n    is_integer = isinstance(x, int)\n    print(f\"type={str(t):17}: {is_number=}, {is_float=}, {is_integer=}\")\n\n\ncheck_types(42)\ncheck_types(3.14)\ncheck_types(1 + 1j)\n\n\n\n","type":"content","url":"/2#id","position":3},{"hierarchy":{"lvl1":"Домашнее задание №2","lvl2":"Сравнение с None"},"type":"lvl2","url":"/2#id-none","position":4},{"hierarchy":{"lvl1":"Домашнее задание №2","lvl2":"Сравнение с None"},"content":"Значение \n\nNone в python имеет множество применений. Например, если функция завершается без ключевого слова return, то эта функция все равно вернет значение None.\n\ndef hello():\n    print(\"Hello\")\n\nx = hello()\nprint(f\"{x=}\")\n\n\n\nАбсолютно такой же эффект возникает, если функция завершается ключевым словом return, справа от которого не указано никакого значения.\n\ndef hello():\n    print(\"Hello\")\n    return\n\nx = hello()\nprint(f\"{x=}\")\n\n\n\nКроме этого значение None часто используется в качестве значений по умолчанию опциональных параметров функции, в качестве значения \n\nслабой ссылки, указывающей на уже освобожденный ресурс, и т.д. В пользовательском коде None часто используют для индикации отсутствующих значений.\n\nПовсеместное употребление None обуславливается не только договором сообщества программистов, но и тем, как это само значение устроенно. Дело в том, что None реализован по шаблону программирования \n\nодиночка: на самом деле есть класс NoneType у которого гарантировано всегда есть единственный экземпляр None. Иными словами в исходном коде программы может многократно встречаться None, но в момент исполнения программы гарантируется, что всего будет создан единственный объект None, а при попытке создания нового будет всегда возвращаться ссылка на уже существующий.\n\nx = None\ny = None\nprint(x is y)\n\n\n\nВ связи с этим в python принято сравнивать с None, используя именно ключевое слово is, а не оператор ==, т.е. принято делать такif x is None:\n    ...\n\nif y is not None:\n    ...\n\nа не такif x == None:\n    ...\n\nif y != None:\n    ...\n\nNote\n\nНапомним, что оператор is проверяет, указывают ли два имени на один и тот же объект, а оператор == сравнивает два объекта на равенство. Оператор is всегда работает быстрее, т.к. сравнивает всего-навсего значения ссылок, а оператор == кроме того, что всегда медленнее, но ещё и может быть перегружен не очевидным образом.\n\n","type":"content","url":"/2#id-none","position":5},{"hierarchy":{"lvl1":"Домашнее задание №2","lvl2":"Проверка на пустоту коллекции"},"type":"lvl2","url":"/2#id-1","position":6},{"hierarchy":{"lvl1":"Домашнее задание №2","lvl2":"Проверка на пустоту коллекции"},"content":"Нередко требуется проверить, является ли коллекция пустой, прежде чем что-то с ней сделать. В качестве примера напишем функцию tail, которая принимает на вход последовательность и возвращает последний элемент этой последовательности.\n\ndef tail(collection):\n    return collection[-1]\n\nprint(f'{tail(\"xyz\")=}')        # строка\nprint(f'{tail([1, 2, 3])=}')    # список\nprint(f'{tail((42, 43, 44))=}') # кортеж\nprint(f'{tail(range(15))=}')    # диапазон\n\n\n\nВидим, что такой код успешно работает для непустых строк, списков, кортежей, диапазонов и, на самом деле, для любых других последовательностей. Но если подать на вход такой функции пустую коллекцию, то возникнет ошибка с обращением по индексу за пределы диапазона последовательности.\n\ntail(\"\")\n\n\n\nМодифицируем код этой функции таким образом, чтобы она возвращала None, если коллекция пустая (а значит нет ни первого ни последнего элемента). Начинающему программисту на ум может прийти следующая конструкция.if len(collection) == 0: \n    return None\n\nТ.е. непосредственное сравнение количества элементов с 0. Такой код будет работать, но в сообществе python считается хорошей практикой более элегантная конструкция.\n\nЕсли требуется проверить, содержит коллекция collection хотя бы один элемент, то применяется конструкция видаif collection:\n    return None\n\nЕсли требуется проверить, пуста ли коллекция collection , то применяется конструкция видаif not collection:\n    return None\n\nТакой подход опирается на тот факт, что все встроенные коллекции при приведении к булевому значению дают True, если в них есть хотя бы один элемент.\n\nМодифицируем функцию tail используя одну из вышеприведенных конструкций.\n\ndef tail(collection):\n    if not collection: # <----\n        return None\n    return collection[-1]\n\n\nprint(f'{tail(\"\")=}')           # пустая строка\nprint(f'{tail([])=}')           # пустой список\nprint(f'{tail(())=}')           # пустой кортеж\nprint(f'{tail(range(0, 0))=}')  # пустой диапазон\n\nprint(f'{tail(\"xyz\")=}')        # строка\nprint(f'{tail([1, 2, 3])=}')    # список\nprint(f'{tail((42, 43, 44))=}') # кортеж\nprint(f'{tail(range(15))=}')    # диапазон\n\n\n\n","type":"content","url":"/2#id-1","position":7},{"hierarchy":{"lvl1":"Домашнее задание №2","lvl2":"Задачи"},"type":"lvl2","url":"/2#id-2","position":8},{"hierarchy":{"lvl1":"Домашнее задание №2","lvl2":"Задачи"},"content":"","type":"content","url":"/2#id-2","position":9},{"hierarchy":{"lvl1":"Домашнее задание №2","lvl3":"1. Фильтрация пропущенных значений. None","lvl2":"Задачи"},"type":"lvl3","url":"/2#id-1-none","position":10},{"hierarchy":{"lvl1":"Домашнее задание №2","lvl3":"1. Фильтрация пропущенных значений. None","lvl2":"Задачи"},"content":"Предположим некий физический измерительный прибор выдаёт результаты измерения в виде списка, при этом если при каком-то очередном измерении произошел сбой и результатам измерения доверять нельзя, то в качестве результата измерения записывается значение None. В качестве примера рассмотрим следующий список:[3.14, \\mathrm{None}, \\mathrm{None}, 2.71, 1.41]\n\nЗначение None на второй и третей позициях этого списка указывает на то, что эти значения были пропущены. Напишите функцию, которая принимает на вход список такого вида L, а возвращает список, состоящий только из непропущенных значений списка L.def filter_missed_values(L):\n    ...\n\n\nL = [3.14, None, None, 2.71, 1.41]\nprint(filter_missed_values(L)) # [3.14, 2.71, 1.41]\n\nДополнительное необязательное задание\n\nПредположим, что вместо пропущенных значений прибор записывает не значение None, а значение NaN (Not a Number), которое в python можно получить выражением float(\"nan\") или в модуле \n\nmath. Как изменится код функции filter_missed_values в таком случае?","type":"content","url":"/2#id-1-none","position":11},{"hierarchy":{"lvl1":"Домашнее задание №2","lvl3":"2. Средние значения","lvl2":"Задачи"},"type":"lvl3","url":"/2#id-2-1","position":12},{"hierarchy":{"lvl1":"Домашнее задание №2","lvl3":"2. Средние значения","lvl2":"Задачи"},"content":"Ваша задача реализовать 3 функции, принимающих на вход последовательность чисел L=[x_1,\\ldots,x_n] и возвращающих одно из средних. Случай пустой последовательности обработайте особым образом.\n\nфункция arithmetic_mean --- \n\nсреднее арифметическое:A\\bigl(\\{x_1, \\ldots, x_n\\}\\bigr) = \\dfrac{1}{n}\\sum_{i=1}^n x_i.def arithmetic_mean(x):\n    ...\n\nфункция geometric_mean --- \n\nсреднее геометрическое:G\\bigl(\\{x_1, \\ldots, x_n\\}\\bigr) = \\sqrt[n]{x_1 x_2 \\cdots x_n}.def geometric_mean(x):\n    ...\n\nфункция harmonic_mean --- \n\nгармоническое среднее:H\\bigl(\\{x_1, \\ldots, x_n\\}\\bigr) = \\dfrac{n}{\\sum\\limits_{i=1}^n\\dfrac{1}{x_i}}.def harmonic_mean(x):\n    ...\n\nфункция median --- \n\nмедиана:M\\bigl(\\{x_1, \\ldots, x_n\\}\\bigr) = \n\\begin{cases}\nX_{\\frac{n+1}{2}}, & \\text{если } n \\text{ нечетно}, \\\\ \n\\left(X_{\\frac{n}{2}} + X_{\\frac{n}{2} + 1}\\right) \\biggr/ 2, &  \\text{если } n \\text{ четно}. \n\\end{cases}\n\nЗдесь X_1, \\ldots, X_n --- упорядоченный по возрастанию значений ряд чисел x_1, \\dots, x_n, от которого вычисляется медиана.def median(x):\n    ...\n\nNote\n\nВаши функции должны быть реализованы с нуля и не должны содержать в себе вызовов функций из модуля стандартной библиотеки \n\nstatistics, а также любых других сторонних библиотек. Однако разрешается использовать эти функции, для тестирования поведения ваших функций.\n\nДополнительное задание\n\nПротестируйте функцию arithmetic_mean на списках [1.e20, 0., 1., -1.e20] и [10**20, 0, 1, -10**20] и попытайтесь объяснить результат. Сравните результат с работой функции \n\nmean из модуля стандартной библиотеки \n\nstatistics на тех же примерах.","type":"content","url":"/2#id-2-1","position":13},{"hierarchy":{"lvl1":"Домашнее задание №2","lvl3":"3. Расстояние между объектами","lvl2":"Задачи"},"type":"lvl3","url":"/2#id-3","position":14},{"hierarchy":{"lvl1":"Домашнее задание №2","lvl3":"3. Расстояние между объектами","lvl2":"Задачи"},"content":"Предположим, что вы пишите программный комплекс для анализа данных как числовой природы, так и текстового характера. Вам известно, что вам придется вычислять расстояния между объектами обоих классов. В качестве расстояния между двумя числами x,\\, y\\in\\mathbb{R} вы выбрали модуль разницы\\rho(x, y) = |x-y|,\n\nа в качестве расстояния между строками одинаковой длины s_1 и s_2 вы выбрали \n\nрасстояние Хэмминга\\rho(s_1, s_2) =  |\\{s_1^i \\neq s_2^i\\mid i=0,\\ldots,n-1\\}|,\n\nгде s_1^i и s_2^i --- i-е символы строк s_1 и s_2 соответственно, n = \\mathrm{len}(s_1) = \\mathrm{len}(s_2) --- длина каждой строки, а |\\cdot| обозначает мощность множества. Иными словами расстояние Хэмминга --- число позиций, в которых соответствующие символы двух слов одинаковой длины различны.\n\nРеализуйте функцию distance(x, y), которая будет возвращать расстояние Хэмминга, если x и y строкового типа, и модуль разницы, если x и y числового типа.def distance(x, y):\n    ...\n\n\nprint(distance(42, 13))                 # 29\nprint(distance(3.14, 2.71))             # 0.43000000000000016\nprint(distance(1 + 2j, 3 + 4j))         # 2.8284271247461903\nprint(distance(\"абв\", \"вба\"))           # 2\nprint(distance(\"Течение\", \"Течении\"))   # 1","type":"content","url":"/2#id-3","position":15},{"hierarchy":{"lvl1":"Introduction"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Introduction"},"content":"This is my abstract!\n\nI am a book about ... something! Wikipedia has \n\ninformation about books: hover over the link for more information.An admonition containing a note\n\nNote\n\nBooks are usually written on paper ... But Jupyter Book can create websites!\n\nIf you sold 100 books at $10 per book, you’d have $1000 dollars according to \n\n(1). If instead you publish your Jupyter Book to the web for free, you’d have $0 dollars!An arbitrary math equationx \\times y = z\n\nSometimes when reading it is helpful to foster a tranquil environment. The image in \n\nFigure 1 would be a perfect spot!A figure of a photograph of some mountains, followed by a caption\n\n\n\nFigure 1:A photograph of some beautiful mountains to look at whilst reading.","type":"content","url":"/","position":1}]}